<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css" id="theme">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css" id="highlight-theme">
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					APIs in Servant
				</section>
				<section>
					<h3>
						Who am I?
					</h3>
					<p>
						Owen Harvey
					</p>
					<p>
						Software Developer
					</p>
					<p>
						CSIRO Data61: E&amp;D
					</p>
				</section>

				<section>
					<section>
						<h4>
							Assumed Knowledge
						</h4>
						<p>
							Servant requires a fair degree of comfort with some advanced Haskell concepts.
						</p>
					</section>
					<section>
						<p>
							Assumptions going into this talk
							<ul>
								<li>Typeclasses</li>
								<li>mtl/transformers</li>
								<li>handwaving extensions</li>
							</ul>
						</p>
					</section>
					<section>
						<p>
							Assume this throughout
						</p>
						<pre><code class="language-haskell" data-trim data-noescape>
							{-# LANGUAGE DataKinds             #-}
							{-# LANGUAGE FlexibleContexts      #-}
							{-# LANGUAGE FlexibleInstances     #-}
							{-# LANGUAGE MultiParamTypeClasses #-}
							{-# LANGUAGE OverloadedStrings     #-}
							{-# LANGUAGE TypeFamilies          #-}
							{-# LANGUAGE TypeOperators         #-}
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h4>
							What is Servant
						</h4>
						<p class="fragment" >
							Type driven library for writing web clients and servers
						</p>
					</section>
					<section>
						<h4>
							Why you should care
						</h4>
						<p>
							<ul>
								<li>
									Composable APIs
								</li>
								<li>
									Client generation from API type
								</li>
								<li>
									Swagger/OpenAPI output (with a util library)
								</li>
								<li>
									Enforced types from top to bottom
								</li>
							</ul>
						</p>
					</section>
				</section>

				<section>
					<section>
						<h4>
							How Servant Works
						</h4>
					</section>
					<section>
						<p>
							Built around a set of combinators for building an API
						</p>
						<p>
							Path, Query, Body, Method, Headers, etc.
						</p>
						<p>
							
						</p>
					</section>
				</section>

				<section>
					<section>
						<h4>
							Writing a Servant API
						</h4>
					</section>
					<section>
						<pre><code class="language-haskell" data-trim data-noescape>
							import Servant ((:>), Get, JSON)

							type TestAPI = "hello" :> "world" :> Get '[JSON] String
						</code></pre>
						<p>
							'[JSON] defines the encodings we can use.
						</p>
						<p>
							String says we will be returning a String to the user.
						</p>
					</section>
					<section>
						<p>
							Multiple routes can be defined in a single type using
						</p>
						<p>
							:<|>
						</p>
						<pre><code class="language-haskell" data-trim data-noescape>
						import Servant ((:>), Get, JSON, (:<|>))

						type Foo = "foo" :> Get '[JSON] ()
						type Bar = "bar" :> Get '[JSON] ()

						type FooBar = Foo :<|> Bar
						type FooBar' =
							"foo" :> Get '[JSON] () :<|>
							"bar" :> Get '[JSON] ()
						</code></pre>
					</section>

					<section>
						<p>
							Routes with a common root can be combined
						</p>
						<pre><code class="language-haskell" data-trim data-noescape>
						type CommonPrefix = "prefix":> (Foo :<|> Bar)
						</code></pre>
						<p class="fragment">
							This is especially useful for handling authentication
						</p>
					</section>
				</section>
				
				<section>
					<section>
						<h4>Anatomy of a Servant server</h4>
					</section>
					<section>
						<p>
							Servant servers are usually split into 3 broad sections
						</p>
						<ul class="fragment">
							<li>API type</li>
							<li>Server function mapping</li>
							<li>Application types and code</li>
						</ul>
					</section>
					<section>
						<h4>
							The API Type
						</h4>
						<p>
							What we looked at before
						</p>
						<ul>
							<li>Routes</li>
							<li>Path and Query Names</li>
							<li>Body and Response Types</li>
							<li>Encodings</li>
							<li>Expected and Response Headers</li>
							<li>Acceptable Methods</li>
						</ul>
					</section>
					<section>
						<p>
							Heavily dependent on typeclasses to handle encodings
						</p>
						<p>
							Most basic types are handled for you
						</p>
						<p>
							Some encodings can be derived by the compiler or provided by hand
						</p>
					</section>
					<section>
						<h4>Server Function Mapping</h4>
						<p>
							Telling servant what to run
						</p>
						<p>
							Uses the same combinators as the type definition
						</p>
					</section>
					<section>
						<pre><code class="language-haskell" data-trim data-noescape>
						type FooBar =
							"foo" :> Capture "x" Bool :> Get '[JSON] String :<|>
							"bar" :> Get '[JSON] Integer

						foo :: MonadIO m => Bool -> m String
						foo = ...

						bar :: MonadIO m => m Integer
						bar = ...
						
						fooBarServer :: MonadIO m => ServerT FooBar m
						fooBarServer = foo :<|> bar
						</code></pre>
					</section>
					<section>
						<p>
							Rules of Thumb
						</p>
						<p>
							Each top level type joined by :<|> requires a function
						</p>
						<p>
							Values are passed in the order they are defined
						</p>
						<p>
							Must all return the same `m`
						</p>
					</section>
				</section>

				<section>
					<section>
						<h4>Servant Clients</h4>
					</section>
					<section>

					</section>
				</section>

				<section>
					<section>
						<h4>Swagger</h4>
					</section>
					<section>
						<p>
							Automatic Swagger/OpenAPI generation
						</p>
						<p>
							Completely type driven
						</p>
					</section>
					<section>
						<pre><code class="language-haskell" data-trim data-noescape>
							{-# LANGUAGE DataKinds        #-}
							{-# LANGUAGE TypeApplications #-}
							module Main where
							import           Data.Aeson                 (encode)
							import           Data.ByteString.Lazy.Char8 (putStrLn)
							import           Data.Proxy                 (Proxy (Proxy))
							import           Endpoints                  (PublicAPI)
							import           Prelude                    (IO, ($), (.))
							import           Servant.Auth               (Cookie, JWT)
							import           Servant.Auth.Swagger       ()
							import           Servant.Swagger            (toSwagger)
							main :: IO ()
							main = putStrLn . encode $
								toSwagger @(PublicAPI '[JWT, Cookie]) Proxy
						</code></pre>
					</section>
				</section>

				<section>
					<section>
						<h4>
							Error handling
						</h4>
					</section>
				</section>

				<section>
					<section>
						<h4>Links</h4>
					</section>
					<section>
						Servant : docs.servant.dev
						Hackage : hackage.haskell.org/package/servant
											hackage.haskell.org/package/servant-server
											hackage.haskell.org/package/servant-client
											hackage.haskell.org/package/servant-swagger
						Slides  : github.com/lepsa/servant-talk
					</section>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
